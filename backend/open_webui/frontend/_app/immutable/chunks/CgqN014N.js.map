{"version":3,"file":"CgqN014N.js","sources":["../../../../../../node_modules/dequal/dist/index.mjs","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/array.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/style.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/attr.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/lightable.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/makeElement.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/is.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/callbacks.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/event.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/lifecycle.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/object.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/withGet.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/overridable.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/sleep.js","../../../../../../node_modules/nanoid/non-secure/index.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/id.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/keyboard.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/derivedVisible.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/effect.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/toWritableStores.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/elements.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/click-outside/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/escape-keydown/action.js","../../../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../../../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/floating/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/focus-trap/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/modal/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/popper/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/portal.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/actions/interact-outside/action.js","../../../../../../node_modules/@melt-ui/svelte/dist/internal/helpers/store/toReadableStores.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/hidden-input/create.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/calendar/create.js","../../../../../../node_modules/@melt-ui/svelte/dist/builders/date-picker/create.js","../../../../../../node_modules/bits-ui/dist/internal/attrs.js","../../../../../../node_modules/bits-ui/dist/internal/events.js","../../../../../../node_modules/bits-ui/dist/internal/object.js","../../../../../../node_modules/bits-ui/dist/internal/updater.js","../../../../../../node_modules/bits-ui/dist/bits/floating/helpers.js"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { dequal as deepEqual } from 'dequal';\n/**\n * Returns the element some number before the given index. If the target index is out of bounds:\n *   - If looping is disabled, the first element will be returned.\n *   - If looping is enabled, the last element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function back(array, index, increment, loop = true) {\n    const previousIndex = index - increment;\n    if (previousIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[previousIndex];\n}\n/**\n * Returns the element some number after the given index. If the target index is out of bounds:\n *   - If looping is disabled, the last element will be returned.\n *   - If looping is enabled, the first element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function forward(array, index, increment, loop = true) {\n    const nextIndex = index + increment;\n    if (nextIndex > array.length - 1) {\n        return loop ? array[0] : array[array.length - 1];\n    }\n    return array[nextIndex];\n}\n/**\n * Returns the array element after to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the beginning of the array if the next index is out of bounds?\n */\nexport function next(array, index, loop = true) {\n    if (index === array.length - 1) {\n        return loop ? array[0] : array[index];\n    }\n    return array[index + 1];\n}\n/**\n * Returns the array element prior to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the end of the array if the previous index is out of bounds?\n */\nexport function prev(array, currentIndex, loop = true) {\n    if (currentIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[currentIndex - 1];\n}\n/**\n * Returns the last element in an array.\n * @param array the array.\n */\nexport function last(array) {\n    return array[array.length - 1];\n}\n/**\n * Wraps an array around itself at a given starting index.\n * @example ```ts\n * wrapArray(['a', 'b', 'c', 'd'], 2);\n * // ['c', 'd', 'a', 'b']\n * ```\n * @see https://github.com/radix-ui/primitives\n */\nexport function wrapArray(array, startIndex) {\n    return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n/**\n * Toggles an item in an array. If the item is already in the array,\n * it is removed. Otherwise, it is added.\n * @param item The item to toggle.\n * @param array The array to toggle the item in.\n * @returns The updated array with the item toggled.\n * @template T The type of the items in the array.\n * @example ```typescript\n * const arr = [1, 2, 3];\n * const newArr = toggle(2, arr);\n * // newArr = [1, 3]\n * ```\n */\nexport function toggle(item, array, compare = deepEqual) {\n    const itemIdx = array.findIndex((innerItem) => compare(innerItem, item));\n    if (itemIdx !== -1) {\n        array.splice(itemIdx, 1);\n    }\n    else {\n        array.push(item);\n    }\n    return array;\n}\n/**\n * Splits an array into chunks of a given size.\n * @param arr The array to split.\n * @param size The size of each chunk.\n * @returns An array of arrays, where each sub-array has `size` elements from the original array.\n * @example ```ts\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8];\n * const chunks = chunk(arr, 3);\n * // chunks = [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function chunk(arr, size) {\n    const result = [];\n    for (let i = 0; i < arr.length; i += size) {\n        result.push(arr.slice(i, i + size));\n    }\n    return result;\n}\n/**\n * Checks if the given index is valid for the given array.\n *\n * @param index - The index to check\n * @param arr - The array to check\n */\nexport function isValidIndex(index, arr) {\n    return index >= 0 && index < arr.length;\n}\n","/**\n * A utility function that converts a style object to a string.\n *\n * @param style - The style object to convert\n * @returns The style object as a string\n */\nexport function styleToString(style) {\n    return Object.keys(style).reduce((str, key) => {\n        if (style[key] === undefined)\n            return str;\n        return str + `${key}:${style[key]};`;\n    }, '');\n}\n","import { styleToString } from './style.js';\nexport function disabledAttr(disabled) {\n    return disabled ? true : undefined;\n}\nexport const hiddenInputAttrs = {\n    type: 'hidden',\n    'aria-hidden': true,\n    hidden: true,\n    tabIndex: -1,\n    style: styleToString({\n        position: 'absolute',\n        opacity: 0,\n        'pointer-events': 'none',\n        margin: 0,\n        transform: 'translateX(-100%)',\n    }),\n};\n/**\n * @param portal The value of the `portal` option store.\n * @returns the value of the `data-portal` attribute.\n */\nexport function portalAttr(portal) {\n    if (portal !== null) {\n        return '';\n    }\n    return undefined;\n}\n","export function lightable(value) {\n    function subscribe(run) {\n        run(value);\n        return () => {\n            // don't need to unsub from anything\n        };\n    }\n    return { subscribe };\n}\n","import { derived } from 'svelte/store';\nimport { isBrowser, isHTMLElement, noop } from './index.js';\nimport { lightable } from './store/lightable.js';\nexport function getElementByMeltId(id) {\n    if (!isBrowser)\n        return null;\n    const el = document.querySelector(`[data-melt-id=\"${id}\"]`);\n    return isHTMLElement(el) ? el : null;\n}\nexport const hiddenAction = (obj) => {\n    return new Proxy(obj, {\n        get(target, prop, receiver) {\n            return Reflect.get(target, prop, receiver);\n        },\n        ownKeys(target) {\n            return Reflect.ownKeys(target).filter((key) => key !== 'action');\n        },\n    });\n};\nconst isFunctionWithParams = (fn) => {\n    return typeof fn === 'function';\n};\nexport const emptyMeltElement = makeElement('empty');\nexport function makeElement(name, args) {\n    const { stores, action, returned } = args ?? {};\n    const derivedStore = (() => {\n        if (stores && returned) {\n            // If stores are provided, create a derived store from them\n            return derived(stores, (values) => {\n                const result = returned(values);\n                if (isFunctionWithParams(result)) {\n                    const fn = (...args) => {\n                        return hiddenAction({\n                            ...result(...args),\n                            [`data-melt-${name}`]: '',\n                            action: action ?? noop,\n                        });\n                    };\n                    fn.action = action ?? noop;\n                    return fn;\n                }\n                return hiddenAction({\n                    ...result,\n                    [`data-melt-${name}`]: '',\n                    action: action ?? noop,\n                });\n            });\n        }\n        else {\n            // If stores are not provided, return a lightable store, for consistency\n            const returnedFn = returned;\n            const result = returnedFn?.();\n            if (isFunctionWithParams(result)) {\n                const resultFn = (...args) => {\n                    return hiddenAction({\n                        ...result(...args),\n                        [`data-melt-${name}`]: '',\n                        action: action ?? noop,\n                    });\n                };\n                resultFn.action = action ?? noop;\n                return lightable(resultFn);\n            }\n            return lightable(hiddenAction({\n                ...result,\n                [`data-melt-${name}`]: '',\n                action: action ?? noop,\n            }));\n        }\n    })();\n    const actionFn = (action ??\n        (() => {\n            /** noop */\n        }));\n    actionFn.subscribe = derivedStore.subscribe;\n    return actionFn;\n}\nexport function makeElementArray(name, args) {\n    const { stores, returned, action } = args;\n    const { subscribe } = derived(stores, (values) => returned(values).map((value) => hiddenAction({\n        ...value,\n        [`data-melt-${name}`]: '',\n        action: action ?? noop,\n    })));\n    const actionFn = (action ??\n        (() => {\n            /** noop */\n        }));\n    actionFn.subscribe = subscribe;\n    return actionFn;\n}\nexport function createElHelpers(prefix) {\n    const name = (part) => (part ? `${prefix}-${part}` : prefix);\n    const attribute = (part) => `data-melt-${prefix}${part ? `-${part}` : ''}`;\n    const selector = (part) => `[data-melt-${prefix}${part ? `-${part}` : ''}]`;\n    const getEl = (part) => document.querySelector(selector(part));\n    return {\n        name,\n        attribute,\n        selector,\n        getEl,\n    };\n}\n","export const isBrowser = typeof document !== 'undefined';\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = (v) => typeof v === 'function';\nexport const isLetter = (key) => /^[a-z]$/i.test(key);\nexport function isDocument(element) {\n    return element instanceof Document;\n}\nexport function isElement(element) {\n    return element instanceof Element;\n}\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isHTMLInputElement(element) {\n    return element instanceof HTMLInputElement;\n}\nexport function isHTMLLabelElement(element) {\n    return element instanceof HTMLLabelElement;\n}\nexport function isHTMLButtonElement(element) {\n    return element instanceof HTMLButtonElement;\n}\nexport function isElementDisabled(element) {\n    const ariaDisabled = element.getAttribute('aria-disabled');\n    const disabled = element.getAttribute('disabled');\n    const dataDisabled = element.hasAttribute('data-disabled');\n    if (ariaDisabled === 'true' || disabled !== null || dataDisabled) {\n        return true;\n    }\n    return false;\n}\nexport function isTouch(event) {\n    return event.pointerType === 'touch';\n}\nexport function isLeftClick(event) {\n    return event.button === 0 && event.ctrlKey === false && event.metaKey === false;\n}\nexport function isFocusVisible(element) {\n    return element.matches(':focus-visible');\n}\nexport function isContentEditable(element) {\n    if (!isHTMLElement(element))\n        return false;\n    return element.isContentEditable;\n}\nexport function isNull(value) {\n    return value === null;\n}\nexport function isNumberString(value) {\n    if (isNaN(parseInt(value)))\n        return false;\n    return true;\n}\nexport function isObject(value) {\n    return value !== null && typeof value === 'object';\n}\nexport function isReadable(value) {\n    return isObject(value) && 'subscribe' in value;\n}\nexport function isWritable(value) {\n    return isReadable(value) && 'set' in value;\n}\n","/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param n array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === 'function') {\n                callback(...args);\n            }\n        }\n    };\n}\n/**\n * A no operation function (does nothing)\n */\nexport function noop() {\n    //\n}\n","import { noop } from './callbacks.js';\nimport { isHTMLElement } from './is.js';\n/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\nexport function addMeltEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    if (typeof handler === 'function') {\n        const handlerWithMelt = withMelt((_event) => handler(_event));\n        // Add the event listener to each specified event for the target element(s).\n        events.forEach((_event) => target.addEventListener(_event, handlerWithMelt, options));\n        // Return a function that removes the event listener from the target element(s).\n        return () => {\n            events.forEach((_event) => target.removeEventListener(_event, handlerWithMelt, options));\n        };\n    }\n    return () => noop();\n}\nexport function dispatchMeltEvent(originalEvent) {\n    const node = originalEvent.currentTarget;\n    if (!isHTMLElement(node))\n        return null;\n    const customMeltEvent = new CustomEvent(`m-${originalEvent.type}`, {\n        detail: {\n            originalEvent,\n        },\n        cancelable: true,\n    });\n    node.dispatchEvent(customMeltEvent);\n    return customMeltEvent;\n}\nexport function withMelt(handler) {\n    return (event) => {\n        const customEvent = dispatchMeltEvent(event);\n        if (customEvent?.defaultPrevented)\n            return;\n        return handler(event);\n    };\n}\n","import { onDestroy, onMount } from 'svelte';\nexport const safeOnMount = (fn) => {\n    try {\n        onMount(fn);\n    }\n    catch {\n        return fn;\n    }\n};\nexport const safeOnDestroy = (fn) => {\n    try {\n        onDestroy(fn);\n    }\n    catch {\n        return fn;\n    }\n};\n","import { dequal } from 'dequal';\nexport function omit(obj, ...keys) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\nexport function stripValues(inputObject, toStrip, recursive) {\n    return Object.fromEntries(Object.entries(inputObject).filter(([_, value]) => !dequal(value, toStrip)));\n}\nexport function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n","import { get, writable } from 'svelte/store';\n/**\n * Transforms an existing store into a store with a `get` method.\n * Uses subscriptions to keep the value up to date, so make sure to call `destroy` when you're done with it.\n * @date 20/01/2024 - 16:38:39\n *\n * @export\n * @template {Readable<unknown>} T\n * @param {T} store\n * @returns {WithGet<T>}\n */\nexport function withGet(store) {\n    return {\n        ...store,\n        get: () => get(store),\n    };\n}\nwithGet.writable = function (initial) {\n    const internal = writable(initial);\n    let value = initial;\n    return {\n        subscribe: internal.subscribe,\n        set(newValue) {\n            internal.set(newValue);\n            value = newValue;\n        },\n        update(updater) {\n            const newValue = updater(value);\n            internal.set(newValue);\n            value = newValue;\n        },\n        get() {\n            return value;\n        },\n    };\n};\nwithGet.derived = function (stores, fn) {\n    const subscribers = new Map();\n    const get = () => {\n        const values = Array.isArray(stores) ? stores.map((store) => store.get()) : stores.get();\n        return fn(values);\n    };\n    const subscribe = (subscriber) => {\n        const unsubscribers = [];\n        const storesArr = Array.isArray(stores) ? stores : [stores];\n        storesArr.forEach((store) => {\n            unsubscribers.push(store.subscribe(() => {\n                subscriber(get());\n            }));\n        });\n        subscriber(get());\n        subscribers.set(subscriber, unsubscribers);\n        return () => {\n            const unsubscribers = subscribers.get(subscriber);\n            if (unsubscribers) {\n                for (const unsubscribe of unsubscribers) {\n                    unsubscribe();\n                }\n            }\n            subscribers.delete(subscriber);\n        };\n    };\n    return {\n        get,\n        subscribe,\n    };\n};\nexport function addGetToStores(stores) {\n    return Object.keys(stores).reduce((acc, key) => {\n        return {\n            ...acc,\n            [key]: withGet(stores[key]),\n        };\n    }, {});\n}\n","import { withGet } from './withGet.js';\nexport const overridable = (_store, onChange) => {\n    const store = withGet(_store);\n    const update = (updater, sideEffect) => {\n        store.update((curr) => {\n            const next = updater(curr);\n            let res = next;\n            if (onChange) {\n                res = onChange({ curr, next });\n            }\n            sideEffect?.(res);\n            return res;\n        });\n    };\n    const set = (curr) => {\n        update(() => curr);\n    };\n    return {\n        ...store,\n        update,\n        set,\n    };\n};\n","export function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import { nanoid } from 'nanoid/non-secure';\n/**\n * A function that generates a random id\n * @returns An id\n */\nexport function generateId() {\n    return nanoid(10);\n}\nexport function generateIds(args) {\n    return args.reduce((acc, curr) => {\n        acc[curr] = generateId();\n        return acc;\n    }, {});\n}\nexport function stringifiedIdObjType(args) {\n    return `Record<${args.map((arg) => `\"${arg}\"`).join(' | ')}, string>`;\n}\n","/**\n * A constant object that maps commonly used keyboard keys to their corresponding string values.\n * This object can be used in other parts of the application to handle keyboard input and prevent\n * hard-coded strings throughout.\n */\nexport const kbd = {\n    ALT: 'Alt',\n    ARROW_DOWN: 'ArrowDown',\n    ARROW_LEFT: 'ArrowLeft',\n    ARROW_RIGHT: 'ArrowRight',\n    ARROW_UP: 'ArrowUp',\n    BACKSPACE: 'Backspace',\n    CAPS_LOCK: 'CapsLock',\n    CONTROL: 'Control',\n    DELETE: 'Delete',\n    END: 'End',\n    ENTER: 'Enter',\n    ESCAPE: 'Escape',\n    F1: 'F1',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    HOME: 'Home',\n    META: 'Meta',\n    PAGE_DOWN: 'PageDown',\n    PAGE_UP: 'PageUp',\n    SHIFT: 'Shift',\n    SPACE: ' ',\n    TAB: 'Tab',\n    CTRL: 'Control',\n    ASTERISK: '*',\n    A: 'a',\n    P: 'p',\n};\n/** Key sets for navigation within lists, such as select, menu, and combobox. */\nexport const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];\nexport const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nexport const SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];\nexport const getNextKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n        vertical: kbd.ARROW_DOWN,\n    }[orientation];\n};\nexport const getPrevKey = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        horizontal: dir === 'rtl' ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n        vertical: kbd.ARROW_UP,\n    }[orientation];\n};\nexport const getDirectionalKeys = (dir = 'ltr', orientation = 'horizontal') => {\n    return {\n        nextKey: getNextKey(dir, orientation),\n        prevKey: getPrevKey(dir, orientation),\n    };\n};\n","import { derived } from 'svelte/store';\n/**\n * Helper function to standardize the way we derive a visible state for the\n * popper/floating elements.\n */\nexport function derivedVisible(obj) {\n    const { open, forceVisible, activeTrigger } = obj;\n    return derived([open, forceVisible, activeTrigger], ([$open, $forceVisible, $activeTrigger]) => ($open || $forceVisible) && $activeTrigger !== null);\n}\n","import { derived } from 'svelte/store';\nimport { noop } from '../index.js';\nimport { safeOnDestroy } from '../lifecycle.js';\n/**\n * A utility function that creates an effect from a set of stores and a function.\n * The effect is automatically cleaned up when the component is destroyed.\n *\n * @template S - The type of the stores object\n * @param stores - The stores object to derive from\n * @param fn - The function to run when the stores change\n * @returns A function that can be used to unsubscribe the effect\n */\nexport function effect(stores, fn) {\n    let cb = undefined;\n    // Create a derived store that contains the stores object and an onUnsubscribe function\n    const destroy = derived(stores, (stores) => {\n        cb?.();\n        cb = fn(stores);\n    }).subscribe(noop);\n    const unsub = () => {\n        destroy();\n        cb?.();\n    };\n    // Automatically unsubscribe the effect when the component is destroyed\n    safeOnDestroy(unsub);\n    return unsub;\n}\n","import { writable } from 'svelte/store';\nimport { withGet } from '../withGet.js';\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toWritableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        result[propertyKey] = withGet(writable(value));\n    });\n    return result;\n}\n","import { isHTMLElement } from './is.js';\n/**\n * Get an element's ancestor which has a `data-portal` attribute.\n * This is used to handle nested portals/overlays/dialogs/popovers.\n */\nfunction getPortalParent(node) {\n    let parent = node.parentElement;\n    while (isHTMLElement(parent) && !parent.hasAttribute('data-portal')) {\n        parent = parent.parentElement;\n    }\n    return parent || 'body';\n}\n/**\n * Gets the destination for a portal given the node and a user-specified portal prop.\n * If a portal prop is not `undefined`, it is used as the destination.\n */\nexport function getPortalDestination(node, portalProp) {\n    // user-specified portal prop, use it\n    if (portalProp !== undefined)\n        return portalProp;\n    // find the closest portal parent, or the body if none is found\n    const portalParent = getPortalParent(node);\n    // if the portalParent is the body, we portal to the body\n    // making it a \"top-level\" portal\n    if (portalParent === 'body')\n        return document.body;\n    // if the portalParent is not the body, we have a portal parent\n    // and shouldn't portal to anything so it remains within that parent\n    // so we return `null`\n    return null;\n}\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/clickOutside/clickOutside.ts\nimport { readable } from 'svelte/store';\nimport { addEventListener } from '../../helpers/event.js';\nimport { get } from 'svelte/store';\nimport { isFunction } from '../../helpers/is.js';\n/**\n * Creates a readable store that tracks the latest PointerEvent that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking pointer events.\n */\nconst documentClickStore = readable(undefined, (set) => {\n    /**\n     * Event handler for pointerdown events on the document.\n     * Updates the store's value with the latest PointerEvent and then resets it to undefined.\n     */\n    function clicked(event) {\n        set(event);\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a pointerdown event listener to the document, calling the clicked function when triggered.\n    const unsubscribe = addEventListener(document, 'pointerup', clicked, {\n        passive: false,\n        capture: true,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking pointer events.\n    return unsubscribe;\n});\nexport const useClickOutside = (node, config = {}) => {\n    let options = { enabled: true, ...config };\n    // Returns true if the click outside handler is enabled\n    function isEnabled() {\n        return typeof options.enabled === 'boolean' ? options.enabled : get(options.enabled);\n    }\n    // Handle document clicks\n    const unsubscribe = documentClickStore.subscribe((e) => {\n        // If the click outside handler is disabled, or if the event is null or the node itself, return early\n        if (!isEnabled() || !e || e.target === node) {\n            return;\n        }\n        const composedPath = e.composedPath();\n        // If the target is in the node, return early\n        if (composedPath.includes(node))\n            return;\n        // If an ignore function is passed, check if it returns true\n        if (options.ignore) {\n            if (isFunction(options.ignore)) {\n                if (options.ignore(e))\n                    return;\n            }\n            // If an ignore array is passed, check if any elements in the array match the target\n            else if (Array.isArray(options.ignore)) {\n                if (options.ignore.length > 0 &&\n                    options.ignore.some((ignoreEl) => {\n                        return ignoreEl && (e.target === ignoreEl || composedPath.includes(ignoreEl));\n                    }))\n                    return;\n            }\n        }\n        // If none of the above conditions are met, call the handler\n        options.handler?.(e);\n    });\n    return {\n        update(params) {\n            options = { ...options, ...params };\n        },\n        destroy() {\n            unsubscribe();\n        },\n    };\n};\n","import { addEventListener } from '../../helpers/event.js';\nimport { isFunction, isHTMLElement, isReadable } from '../../helpers/is.js';\nimport { get, readable } from 'svelte/store';\nimport { effect, executeCallbacks, kbd, noop } from '../../helpers/index.js';\n/**\n * Creates a readable store that tracks the latest Escape Keydown that occurred on the document.\n *\n * @returns A function to unsubscribe from the event listener and stop tracking keydown events.\n */\nconst documentEscapeKeyStore = readable(undefined, (set) => {\n    /**\n     * Event handler for keydown events on the document.\n     * Updates the store's value with the latest Escape Keydown event and then resets it to undefined.\n     */\n    function keydown(event) {\n        if (event && event.key === kbd.ESCAPE) {\n            set(event);\n        }\n        // New subscriptions will not trigger immediately\n        set(undefined);\n    }\n    // Adds a keydown event listener to the document, calling the keydown function when triggered.\n    const unsubscribe = addEventListener(document, 'keydown', keydown, {\n        passive: false,\n    });\n    // Returns a function to unsubscribe from the event listener and stop tracking keydown events.\n    return unsubscribe;\n});\nexport const useEscapeKeydown = ((node, config = {}) => {\n    let unsub = noop;\n    function update(config = {}) {\n        unsub();\n        const options = { enabled: true, ...config };\n        const enabled = (isReadable(options.enabled) ? options.enabled : readable(options.enabled));\n        unsub = executeCallbacks(\n        // Handle escape keydowns\n        documentEscapeKeyStore.subscribe((e) => {\n            if (!e || !get(enabled))\n                return;\n            const target = e.target;\n            if (!isHTMLElement(target) || target.closest('[data-escapee]') !== node) {\n                return;\n            }\n            e.preventDefault();\n            // If an ignore function is passed, check if it returns true\n            if (options.ignore) {\n                if (isFunction(options.ignore)) {\n                    if (options.ignore(e))\n                        return;\n                }\n                // If an ignore array is passed, check if any elements in the array match the target\n                else if (Array.isArray(options.ignore)) {\n                    if (options.ignore.length > 0 &&\n                        options.ignore.some((ignoreEl) => {\n                            return ignoreEl && target === ignoreEl;\n                        }))\n                        return;\n                }\n            }\n            // If none of the above conditions are met, call the handler\n            options.handler?.(e);\n        }), effect(enabled, ($enabled) => {\n            if ($enabled) {\n                node.dataset.escapee = '';\n            }\n            else {\n                delete node.dataset.escapee;\n            }\n        }));\n    }\n    update(config);\n    return {\n        update,\n        destroy() {\n            node.removeAttribute('data-escapee');\n            unsub();\n        },\n    };\n});\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/floating/placement.ts\nimport { flip, offset, arrow, shift, size, computePosition, autoUpdate, } from '@floating-ui/dom';\nimport { isHTMLElement, noop } from '../../helpers/index.js';\nconst defaultConfig = {\n    strategy: 'absolute',\n    placement: 'top',\n    gutter: 5,\n    flip: true,\n    sameWidth: false,\n    overflowPadding: 8,\n};\nconst ARROW_TRANSFORM = {\n    bottom: 'rotate(45deg)',\n    left: 'rotate(135deg)',\n    top: 'rotate(225deg)',\n    right: 'rotate(315deg)',\n};\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'];\nconst ALIGN_OPTIONS = ['start', 'center', 'end'];\nexport function useFloating(reference, floating, opts = {}) {\n    if (!floating || !reference || opts === null)\n        return {\n            destroy: noop,\n        };\n    const options = { ...defaultConfig, ...opts };\n    const arrowEl = floating.querySelector('[data-arrow=true]');\n    const middleware = [];\n    if (options.flip) {\n        middleware.push(flip({\n            boundary: options.boundary,\n            padding: options.overflowPadding,\n        }));\n    }\n    const arrowOffset = isHTMLElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;\n    if (options.gutter || options.offset) {\n        const data = options.gutter ? { mainAxis: options.gutter } : options.offset;\n        if (data?.mainAxis != null) {\n            data.mainAxis += arrowOffset;\n        }\n        middleware.push(offset(data));\n    }\n    middleware.push(shift({\n        boundary: options.boundary,\n        crossAxis: options.overlap,\n        padding: options.overflowPadding,\n    }));\n    if (arrowEl) {\n        middleware.push(arrow({ element: arrowEl, padding: 8 }));\n    }\n    middleware.push(size({\n        padding: options.overflowPadding,\n        apply({ rects, availableHeight, availableWidth }) {\n            if (options.sameWidth) {\n                Object.assign(floating.style, {\n                    width: `${Math.round(rects.reference.width)}px`,\n                    minWidth: 'unset',\n                });\n            }\n            if (options.fitViewport) {\n                Object.assign(floating.style, {\n                    maxWidth: `${availableWidth}px`,\n                    maxHeight: `${availableHeight}px`,\n                });\n            }\n        },\n    }));\n    function compute() {\n        if (!reference || !floating)\n            return;\n        // if the reference is no longer in the document (e.g. it was removed), ignore it\n        if (isHTMLElement(reference) && !reference.ownerDocument.documentElement.contains(reference))\n            return;\n        const { placement, strategy } = options;\n        computePosition(reference, floating, {\n            placement,\n            middleware,\n            strategy,\n        }).then((data) => {\n            const x = Math.round(data.x);\n            const y = Math.round(data.y);\n            // get the chosen side and align from the placement to apply as attributes\n            // to the floating element and arrow\n            const [side, align] = getSideAndAlignFromPlacement(data.placement);\n            floating.setAttribute('data-side', side);\n            floating.setAttribute('data-align', align);\n            Object.assign(floating.style, {\n                position: options.strategy,\n                top: `${y}px`,\n                left: `${x}px`,\n            });\n            if (isHTMLElement(arrowEl) && data.middlewareData.arrow) {\n                const { x, y } = data.middlewareData.arrow;\n                const dir = data.placement.split('-')[0];\n                arrowEl.setAttribute('data-side', dir);\n                Object.assign(arrowEl.style, {\n                    position: 'absolute',\n                    left: x != null ? `${x}px` : '',\n                    top: y != null ? `${y}px` : '',\n                    [dir]: `calc(100% - ${arrowOffset}px)`,\n                    transform: ARROW_TRANSFORM[dir],\n                    backgroundColor: 'inherit',\n                    zIndex: 'inherit',\n                });\n            }\n            return data;\n        });\n    }\n    // Apply `position` to floating element prior to the computePosition() call.\n    Object.assign(floating.style, {\n        position: options.strategy,\n    });\n    return {\n        destroy: autoUpdate(reference, floating, compute),\n    };\n}\nfunction getSideAndAlignFromPlacement(placement) {\n    const [side, align = 'center'] = placement.split('-');\n    return [side, align];\n}\n","// Modified from Grail UI v0.9.6 (2023-06-10)\n// Source: https://github.com/grail-ui/grail-ui\n// https://github.com/grail-ui/grail-ui/tree/master/packages/grail-ui/src/focusTrap/focusTrap.ts\nimport { writable, readonly } from 'svelte/store';\nimport { createFocusTrap as _createFocusTrap } from 'focus-trap';\nexport function createFocusTrap(config = {}) {\n    let trap;\n    const { immediate, ...focusTrapOptions } = config;\n    const hasFocus = writable(false);\n    const isPaused = writable(false);\n    const activate = (opts) => trap?.activate(opts);\n    const deactivate = (opts) => {\n        trap?.deactivate(opts);\n    };\n    const pause = () => {\n        if (trap) {\n            trap.pause();\n            isPaused.set(true);\n        }\n    };\n    const unpause = () => {\n        if (trap) {\n            trap.unpause();\n            isPaused.set(false);\n        }\n    };\n    const useFocusTrap = (node) => {\n        trap = _createFocusTrap(node, {\n            ...focusTrapOptions,\n            onActivate() {\n                hasFocus.set(true);\n                config.onActivate?.();\n            },\n            onDeactivate() {\n                hasFocus.set(false);\n                config.onDeactivate?.();\n            },\n        });\n        if (immediate) {\n            activate();\n        }\n        return {\n            destroy() {\n                deactivate();\n                trap = undefined;\n            },\n        };\n    };\n    return {\n        useFocusTrap,\n        hasFocus: readonly(hasFocus),\n        isPaused: readonly(isPaused),\n        activate,\n        deactivate,\n        pause,\n        unpause,\n    };\n}\n","import { isElement, last, noop, sleep } from '../../helpers/index.js';\nimport { useInteractOutside } from '../index.js';\nconst visibleModals = [];\nexport const useModal = ((node, config) => {\n    let unsubInteractOutside = noop;\n    function removeNodeFromVisibleModals() {\n        const index = visibleModals.indexOf(node);\n        if (index >= 0) {\n            visibleModals.splice(index, 1);\n        }\n    }\n    function update(config) {\n        unsubInteractOutside();\n        const { open, onClose, shouldCloseOnInteractOutside, closeOnInteractOutside } = config;\n        sleep(100).then(() => {\n            if (open) {\n                visibleModals.push(node);\n            }\n            else {\n                removeNodeFromVisibleModals();\n            }\n        });\n        function isLastModal() {\n            return last(visibleModals) === node;\n        }\n        function closeModal() {\n            // we only want to call onClose if this is the topmost modal\n            if (isLastModal() && onClose) {\n                onClose();\n                removeNodeFromVisibleModals();\n            }\n        }\n        function onInteractOutsideStart(e) {\n            const target = e.target;\n            if (!isElement(target))\n                return;\n            if (target && isLastModal()) {\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n        function onInteractOutside(e) {\n            if (shouldCloseOnInteractOutside?.(e) && isLastModal()) {\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n                closeModal();\n            }\n        }\n        unsubInteractOutside = useInteractOutside(node, {\n            onInteractOutsideStart,\n            onInteractOutside: closeOnInteractOutside ? onInteractOutside : undefined,\n            enabled: open,\n        }).destroy;\n    }\n    update(config);\n    return {\n        update,\n        destroy() {\n            removeNodeFromVisibleModals();\n            unsubInteractOutside();\n        },\n    };\n});\n","import { createFocusTrap, useEscapeKeydown, useFloating, usePortal, } from '../index.js';\nimport { executeCallbacks, noop, isHTMLElement, } from '../../helpers/index.js';\nimport { useModal } from '../modal/action.js';\nconst defaultConfig = {\n    floating: {},\n    focusTrap: {},\n    modal: {},\n    escapeKeydown: {},\n    portal: 'body',\n};\nexport const usePopper = ((popperElement, args) => {\n    popperElement.dataset.escapee = '';\n    const { anchorElement, open, options } = args;\n    if (!anchorElement || !open || !options) {\n        return { destroy: noop };\n    }\n    const opts = { ...defaultConfig, ...options };\n    const callbacks = [];\n    if (opts.portal !== null) {\n        callbacks.push(usePortal(popperElement, opts.portal).destroy);\n    }\n    callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);\n    if (opts.focusTrap !== null) {\n        const { useFocusTrap } = createFocusTrap({\n            immediate: true,\n            escapeDeactivates: false,\n            allowOutsideClick: true,\n            returnFocusOnDeactivate: false,\n            fallbackFocus: popperElement,\n            ...opts.focusTrap,\n        });\n        callbacks.push(useFocusTrap(popperElement).destroy);\n    }\n    if (opts.modal !== null) {\n        callbacks.push(useModal(popperElement, {\n            onClose: () => {\n                if (isHTMLElement(anchorElement)) {\n                    open.set(false);\n                    anchorElement.focus();\n                }\n            },\n            shouldCloseOnInteractOutside: (e) => {\n                if (e.defaultPrevented)\n                    return false;\n                if (isHTMLElement(anchorElement) && anchorElement.contains(e.target)) {\n                    return false;\n                }\n                return true;\n            },\n            ...opts.modal,\n        }).destroy);\n    }\n    if (opts.escapeKeydown !== null) {\n        callbacks.push(useEscapeKeydown(popperElement, {\n            enabled: open,\n            handler: () => {\n                open.set(false);\n            },\n            ...opts.escapeKeydown,\n        }).destroy);\n    }\n    // @ts-expect-error - This works and is correct, but TS doesn't like it\n    const unsubscribe = executeCallbacks(...callbacks);\n    return {\n        destroy() {\n            unsubscribe();\n        },\n    };\n});\n","import { tick } from 'svelte';\nimport { isHTMLElement, noop } from '../helpers/index.js';\nexport const usePortal = ((el, target = 'body') => {\n    let targetEl;\n    if (!isHTMLElement(target) && typeof target !== 'string') {\n        return {\n            destroy: noop,\n        };\n    }\n    async function update(newTarget) {\n        target = newTarget;\n        if (typeof target === 'string') {\n            targetEl = document.querySelector(target);\n            if (targetEl === null) {\n                await tick();\n                targetEl = document.querySelector(target);\n            }\n            if (targetEl === null) {\n                throw new Error(`No element found matching css selector: \"${target}\"`);\n            }\n        }\n        else if (target instanceof HTMLElement) {\n            targetEl = target;\n        }\n        else {\n            throw new TypeError(`Unknown portal target type: ${target === null ? 'null' : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);\n        }\n        el.dataset.portal = '';\n        targetEl.appendChild(el);\n        el.hidden = false;\n    }\n    function destroy() {\n        el.remove();\n    }\n    update(target);\n    return {\n        update,\n        destroy,\n    };\n});\n","import { addEventListener, isElement, executeCallbacks, noop, } from '../../helpers/index.js';\nexport const useInteractOutside = ((node, config) => {\n    let unsub = noop;\n    let unsubClick = noop;\n    let isPointerDown = false;\n    let isPointerDownInside = false;\n    let ignoreEmulatedMouseEvents = false;\n    function update(config) {\n        unsub();\n        unsubClick();\n        const { onInteractOutside, onInteractOutsideStart, enabled } = config;\n        if (!enabled)\n            return;\n        function onPointerDown(e) {\n            if (onInteractOutside && isValidEvent(e, node)) {\n                onInteractOutsideStart?.(e);\n            }\n            const target = e.target;\n            if (isElement(target) && isOrContainsTarget(node, target)) {\n                isPointerDownInside = true;\n            }\n            isPointerDown = true;\n        }\n        function triggerInteractOutside(e) {\n            onInteractOutside?.(e);\n        }\n        const documentObj = getOwnerDocument(node);\n        // Use pointer events if available, otherwise use mouse/touch events\n        if (typeof PointerEvent !== 'undefined') {\n            const onPointerUp = (e) => {\n                unsubClick();\n                const handler = (e) => {\n                    if (shouldTriggerInteractOutside(e)) {\n                        triggerInteractOutside(e);\n                    }\n                    resetPointerState();\n                };\n                /**\n                 * On touch devices, we need to wait for a click event because browsers implement\n                 * a delay between the time the user stops touching the display and when the\n                 * browser executes the click event. Without waiting for the click event, the\n                 * browser may execute events on other elements that should have been prevented.\n                 */\n                if (e.pointerType === 'touch') {\n                    unsubClick = addEventListener(documentObj, 'click', handler, {\n                        capture: true,\n                        once: true,\n                    });\n                    return;\n                }\n                handler(e);\n            };\n            unsub = executeCallbacks(addEventListener(documentObj, 'pointerdown', onPointerDown, true), addEventListener(documentObj, 'pointerup', onPointerUp, true));\n        }\n        else {\n            const onMouseUp = (e) => {\n                if (ignoreEmulatedMouseEvents) {\n                    ignoreEmulatedMouseEvents = false;\n                }\n                else if (shouldTriggerInteractOutside(e)) {\n                    triggerInteractOutside(e);\n                }\n                resetPointerState();\n            };\n            const onTouchEnd = (e) => {\n                ignoreEmulatedMouseEvents = true;\n                if (shouldTriggerInteractOutside(e)) {\n                    triggerInteractOutside(e);\n                }\n                resetPointerState();\n            };\n            unsub = executeCallbacks(addEventListener(documentObj, 'mousedown', onPointerDown, true), addEventListener(documentObj, 'mouseup', onMouseUp, true), addEventListener(documentObj, 'touchstart', onPointerDown, true), addEventListener(documentObj, 'touchend', onTouchEnd, true));\n        }\n    }\n    function shouldTriggerInteractOutside(e) {\n        if (isPointerDown && !isPointerDownInside && isValidEvent(e, node)) {\n            return true;\n        }\n        return false;\n    }\n    function resetPointerState() {\n        isPointerDown = false;\n        isPointerDownInside = false;\n    }\n    update(config);\n    return {\n        update,\n        destroy() {\n            unsub();\n            unsubClick();\n        },\n    };\n});\nfunction isValidEvent(e, node) {\n    if ('button' in e && e.button > 0)\n        return false;\n    const target = e.target;\n    if (!isElement(target))\n        return false;\n    // if the target is no longer in the document (e.g. it was removed) ignore it\n    const ownerDocument = target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(target)) {\n        return false;\n    }\n    return node && !isOrContainsTarget(node, target);\n}\nfunction isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\nfunction getOwnerDocument(el) {\n    return el?.ownerDocument ?? document;\n}\n","import { readable } from 'svelte/store';\nimport { isReadable } from '../is.js';\nimport { withGet } from '../withGet.js';\n/**\n * Given an object of properties, returns an object of writable stores\n * with the same properties and values.\n */\nexport function toReadableStores(properties) {\n    const result = {};\n    Object.keys(properties).forEach((key) => {\n        const propertyKey = key;\n        const value = properties[propertyKey];\n        if (isReadable(value)) {\n            result[propertyKey] = withGet(value);\n        }\n        else {\n            result[propertyKey] = withGet(readable(value));\n        }\n    });\n    return result;\n}\n","import { createElHelpers, makeElement } from '../../internal/helpers/makeElement.js';\nimport { readable } from 'svelte/store';\nimport { styleToString } from '../../internal/helpers/style.js';\nimport { toReadableStores } from '../../internal/helpers/store/toReadableStores.js';\nimport { omit } from '../../internal/helpers/object.js';\nimport { removeUndefined } from '../../internal/helpers/object.js';\nconst defaults = {\n    prefix: '',\n    disabled: readable(false),\n    required: readable(false),\n    name: readable(undefined),\n};\nexport function createHiddenInput(props) {\n    const withDefaults = {\n        ...defaults,\n        ...removeUndefined(props),\n    };\n    const { name: elName } = createElHelpers(withDefaults.prefix);\n    const { value, name, disabled, required } = toReadableStores(omit(withDefaults, 'prefix'));\n    const nameStore = name; // TODO: Remove this cast when types are fixed\n    const hiddenInput = makeElement(elName('hidden-input'), {\n        stores: [value, nameStore, disabled, required],\n        returned: ([$value, $name, $disabled, $required]) => {\n            return {\n                name: $name,\n                value: $value?.toString(),\n                'aria-hidden': 'true',\n                hidden: true,\n                disabled: $disabled,\n                required: $required,\n                tabIndex: -1,\n                style: styleToString({\n                    position: 'absolute',\n                    opacity: 0,\n                    'pointer-events': 'none',\n                    margin: 0,\n                    transform: 'translateX(-100%)',\n                }),\n            };\n        },\n        action: (node) => {\n            // When value changes, emit a change event\n            const unsub = value.subscribe((newValue) => {\n                node.value = newValue;\n                node.dispatchEvent(new Event('change', { bubbles: true }));\n            });\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    return hiddenInput;\n}\n","import { addMeltEventListener, makeElement, createElHelpers, effect, executeCallbacks, generateIds, isBrowser, isHTMLElement, isValidIndex, kbd, omit, overridable, styleToString, toWritableStores, withGet, } from '../../internal/helpers/index.js';\nimport { createFormatter, createMonths, dateStore, getAnnouncer, getDefaultDate, getSelectableCells, isAfter, isBefore, isCalendarCell, parseStringToDateValue, setPlaceholderToNodeValue, toDate, } from '../../internal/helpers/date/index.js';\nimport { getLocalTimeZone, isSameDay, isSameMonth, isToday, } from '@internationalized/date';\nimport { tick } from 'svelte';\nimport { derived, writable } from 'svelte/store';\nexport const defaults = {\n    isDateDisabled: undefined,\n    isDateUnavailable: undefined,\n    value: undefined,\n    preventDeselect: false,\n    numberOfMonths: 1,\n    pagedNavigation: false,\n    weekStartsOn: 0,\n    fixedWeeks: false,\n    calendarLabel: 'Event Date',\n    locale: 'en',\n    minValue: undefined,\n    maxValue: undefined,\n    disabled: false,\n    readonly: false,\n    weekdayFormat: 'narrow',\n};\nconst { name } = createElHelpers('calendar');\nexport const calendarIdParts = ['calendar', 'accessibleHeading'];\nexport function createCalendar(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores({\n        ...omit(withDefaults, 'value', 'placeholder', 'multiple', 'ids'),\n        multiple: withDefaults.multiple ?? false,\n    });\n    const { preventDeselect, numberOfMonths, pagedNavigation, weekStartsOn, fixedWeeks, calendarLabel, locale, minValue, maxValue, multiple, isDateUnavailable, disabled, readonly, weekdayFormat, } = options;\n    const ids = toWritableStores({ ...generateIds(calendarIdParts), ...withDefaults.ids });\n    const defaultDate = getDefaultDate({\n        defaultPlaceholder: withDefaults.defaultPlaceholder,\n        defaultValue: withDefaults.defaultValue,\n    });\n    const formatter = createFormatter(withDefaults.locale);\n    const valueWritable = withDefaults.value ?? writable(withDefaults.defaultValue);\n    const value = overridable(valueWritable, withDefaults.onValueChange);\n    const placeholderWritable = withDefaults.placeholder ?? writable(withDefaults.defaultPlaceholder ?? defaultDate);\n    const placeholder = dateStore(overridable(placeholderWritable, withDefaults.onPlaceholderChange), withDefaults.defaultPlaceholder ?? defaultDate);\n    /**\n     * A store containing the months to display in the calendar.\n     */\n    const months = withGet(writable(createMonths({\n        dateObj: placeholder.get(),\n        weekStartsOn: withDefaults.weekStartsOn,\n        locale: withDefaults.locale,\n        fixedWeeks: withDefaults.fixedWeeks,\n        numberOfMonths: withDefaults.numberOfMonths,\n    })));\n    /**\n     * A derived store that maintains the currently visible months in the calendar,\n     * which we use to determine how keyboard navigation and if we should apply\n     * `data-outside-month` to cells.\n     */\n    const visibleMonths = withGet.derived([months], ([$months]) => {\n        return $months.map((month) => {\n            return month.value;\n        });\n    });\n    const isOutsideVisibleMonths = derived([visibleMonths], ([$visibleMonths]) => {\n        return (date) => {\n            return !$visibleMonths.some((month) => isSameMonth(date, month));\n        };\n    });\n    const isNextButtonDisabled = withGet.derived([months, maxValue, disabled], ([$months, $maxValue, $disabled]) => {\n        if (!$maxValue || !$months.length)\n            return false;\n        if ($disabled)\n            return true;\n        const lastMonthInView = $months[$months.length - 1].value;\n        const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });\n        return isAfter(firstMonthOfNextPage, $maxValue);\n    });\n    const isPrevButtonDisabled = withGet.derived([months, minValue, disabled], ([$months, $minValue, $disabled]) => {\n        if (!$minValue || !$months.length)\n            return false;\n        if ($disabled)\n            return true;\n        const firstMonthInView = $months[0].value;\n        const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });\n        return isBefore(lastMonthOfPrevPage, $minValue);\n    });\n    /**\n     * A derived store function that determines if a date is disabled based\n     * on the `isDateDisabled` prop, `minValue`, and `maxValue` props.\n     */\n    const isDateDisabled = withGet.derived([options.isDateDisabled, minValue, maxValue, disabled], ([$isDateDisabled, $minValue, $maxValue, $disabled]) => {\n        return (date) => {\n            if ($isDateDisabled?.(date) || $disabled)\n                return true;\n            if ($minValue && isBefore(date, $minValue))\n                return true;\n            if ($maxValue && isBefore($maxValue, date))\n                return true;\n            return false;\n        };\n    });\n    const isDateSelected = derived([value], ([$value]) => {\n        return (date) => {\n            if (Array.isArray($value)) {\n                return $value.some((d) => isSameDay(d, date));\n            }\n            else if (!$value) {\n                return false;\n            }\n            else {\n                return isSameDay($value, date);\n            }\n        };\n    });\n    /**\n     * A derived helper store that evaluates to true if a currently selected date is invalid.\n     */\n    const isInvalid = derived([value, isDateDisabled, options.isDateUnavailable], ([$value, $isDateDisabled, $isDateUnavailable]) => {\n        if (Array.isArray($value)) {\n            if (!$value.length)\n                return false;\n            for (const date of $value) {\n                if ($isDateDisabled?.(date))\n                    return true;\n                if ($isDateUnavailable?.(date))\n                    return true;\n            }\n        }\n        else {\n            if (!$value)\n                return false;\n            if ($isDateDisabled?.($value))\n                return true;\n            if ($isDateUnavailable?.($value))\n                return true;\n        }\n        return false;\n    });\n    /**\n     * Initialize the announcer, which currently remains inactive in this context since it will\n     * be server-side rendered, but we'll initialize it in the calendar's action.\n     *\n     * The announcer is in charge of providing `aria-live` announcements for the calendar,\n     * such as when a date is selected.\n     */\n    let announcer = getAnnouncer();\n    /**\n     * The current heading value for the calendar, meant to be utilized with\n     * the {@link heading} builder.\n     * It renders the current displayed month and year, formatted for the current locale.\n     * This value updates automatically as the user navigates the calendar, even when\n     * displaying multiple months using the `numberOfMonths` prop.\n     */\n    const headingValue = withGet.derived([months, locale], ([$months, $locale]) => {\n        if (!$months.length)\n            return '';\n        if ($locale !== formatter.getLocale()) {\n            formatter.setLocale($locale);\n        }\n        if ($months.length === 1) {\n            const month = $months[0].value;\n            return `${formatter.fullMonthAndYear(toDate(month))}`;\n        }\n        const startMonth = toDate($months[0].value);\n        const endMonth = toDate($months[$months.length - 1].value);\n        const startMonthName = formatter.fullMonth(startMonth);\n        const endMonthName = formatter.fullMonth(endMonth);\n        const startMonthYear = formatter.fullYear(startMonth);\n        const endMonthYear = formatter.fullYear(endMonth);\n        const content = startMonthYear === endMonthYear\n            ? `${startMonthName} - ${endMonthName} ${endMonthYear}`\n            : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;\n        return content;\n    });\n    /**\n     * The accessible heading label for the calendar, generated by combining the `calendarLabel`\n     * prop and the `headingValue` store to create a label like `Event Date, January 2021`.\n     */\n    const fullCalendarLabel = withGet.derived([headingValue, calendarLabel], ([$headingValue, $calendarLabel]) => {\n        return `${$calendarLabel}, ${$headingValue}`;\n    });\n    /**\n     * The root element of the calendar, capable of housing multiple grids/months\n     * when using paged navigation.\n     */\n    const calendar = makeElement(name(), {\n        stores: [fullCalendarLabel, isInvalid, disabled, readonly, ids.calendar],\n        returned: ([$fullCalendarLabel, $isInvalid, $disabled, $readonly, $calendarId]) => {\n            return {\n                id: $calendarId,\n                role: 'application',\n                'aria-label': $fullCalendarLabel,\n                'data-invalid': $isInvalid ? '' : undefined,\n                'data-disabled': $disabled ? '' : undefined,\n                'data-readonly': $readonly ? '' : undefined,\n            };\n        },\n        action: (node) => {\n            /**\n             * Generates the accessible calendar heading when the grid is mounted.\n             * The label is dynamically updated through an effect whenever there\n             * are changes in the active date or label.\n             */\n            createAccessibleHeading(node, fullCalendarLabel.get());\n            announcer = getAnnouncer();\n            const unsubKb = addMeltEventListener(node, 'keydown', handleCalendarKeydown);\n            return {\n                destroy() {\n                    unsubKb();\n                },\n            };\n        },\n    });\n    /**\n     * The calendar heading, visually displaying the current month and year. This heading\n     * is hidden from screen readers as an accessible heading is automatically generated\n     * for the calendar.\n     *\n     * To customize the accessible heading's prefix, use the `calendarLabel` prop. By default,\n     * the accessible heading reads as `Event Date, January 2021` for January 2021. If you set\n     * the `calendarLabel` prop to 'Booking Date', the accessible heading will be 'Booking Date,\n     * January 2021' for the same month and year.\n     */\n    const heading = makeElement(name('heading'), {\n        stores: [disabled],\n        returned: ([$disabled]) => {\n            return {\n                'aria-hidden': true,\n                'data-disabled': $disabled ? '' : undefined,\n            };\n        },\n    });\n    /**\n     * A grid element that serves as a container for a single month in the calendar.\n     * Grids should be rendered for each month present in the `months` store returned\n     * by the `createCalendar` builder.\n     *\n     * For more details about the structure of the month object, refer to {@link Month}.\n     */\n    const grid = makeElement(name('grid'), {\n        stores: [readonly, disabled],\n        returned: ([$readonly, $disabled]) => {\n            return {\n                tabindex: -1,\n                role: 'grid',\n                'aria-readonly': $readonly ? 'true' : undefined,\n                'aria-disabled': $disabled ? 'true' : undefined,\n                'data-readonly': $readonly ? '' : undefined,\n                'data-disabled': $disabled ? '' : undefined,\n            };\n        },\n    });\n    /**\n     * The 'prev' button for the calendar, enabling navigation to the\n     * previous page. In paged navigation mode, it moves the calendar\n     * back by the number of months specified in the `numberOfMonths` prop.\n     * In non-paged mode, it shifts the calendar back by one month.\n     */\n    const prevButton = makeElement(name('prevButton'), {\n        stores: [isPrevButtonDisabled],\n        returned: ([$isPrevButtonDisabled]) => {\n            const disabled = $isPrevButtonDisabled;\n            return {\n                role: 'button',\n                type: 'button',\n                'aria-label': 'Previous',\n                'aria-disabled': disabled ? 'true' : undefined,\n                'data-disabled': disabled ? '' : undefined,\n                disabled: disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                if (isPrevButtonDisabled.get())\n                    return;\n                prevPage();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * A button element designed for navigating to the next page of the calendar.\n     * If using paged navigation, it advances the calendar by the number of months\n     * specified in the `numberOfMonths` prop. If not using paged navigation, it\n     * moves the calendar forward by one month.\n     */\n    const nextButton = makeElement(name('nextButton'), {\n        stores: [isNextButtonDisabled],\n        returned: ([$isNextButtonDisabled]) => {\n            const disabled = $isNextButtonDisabled;\n            return {\n                role: 'button',\n                type: 'button',\n                'aria-label': 'Next',\n                'aria-disabled': disabled ? 'true' : undefined,\n                'data-disabled': disabled ? '' : undefined,\n                disabled: disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                if (isNextButtonDisabled.get())\n                    return;\n                nextPage();\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * Represents an individual date cell in the calendar grid,\n     * signifying a single day within the month. Configured with\n     * essential attributes and event handlers for accessibility\n     * and interactivity.\n     */\n    const cell = makeElement(name('cell'), {\n        stores: [\n            isDateSelected,\n            isDateDisabled,\n            isDateUnavailable,\n            isOutsideVisibleMonths,\n            placeholder,\n        ],\n        returned: ([$isDateSelected, $isDateDisabled, $isDateUnavailable, $isOutsideVisibleMonths, $placeholder,]) => {\n            /**\n             * Applies the appropriate attributes to each date cell in the calendar.\n             *\n             * @params cellValue - The `DateValue` for the current cell.\n             * @params monthValue - The `DateValue` for the current month, which is used\n             * to determine if the current cell is outside the current month.\n             */\n            return (cellValue, monthValue) => {\n                const cellDate = toDate(cellValue);\n                const isDisabled = $isDateDisabled?.(cellValue);\n                const isUnavailable = $isDateUnavailable?.(cellValue);\n                const isDateToday = isToday(cellValue, getLocalTimeZone());\n                const isOutsideMonth = !isSameMonth(cellValue, monthValue);\n                const isOutsideVisibleMonths = $isOutsideVisibleMonths(cellValue);\n                const isFocusedDate = isSameDay(cellValue, $placeholder);\n                const isSelectedDate = $isDateSelected(cellValue);\n                const labelText = formatter.custom(cellDate, {\n                    weekday: 'long',\n                    month: 'long',\n                    day: 'numeric',\n                    year: 'numeric',\n                });\n                return {\n                    role: 'button',\n                    'aria-label': labelText,\n                    'aria-selected': isSelectedDate ? true : undefined,\n                    'aria-disabled': isOutsideMonth || isDisabled || isUnavailable ? true : undefined,\n                    'data-selected': isSelectedDate ? true : undefined,\n                    'data-value': cellValue.toString(),\n                    'data-disabled': isDisabled || isOutsideMonth ? '' : undefined,\n                    'data-unavailable': isUnavailable ? '' : undefined,\n                    'data-today': isDateToday ? '' : undefined,\n                    'data-outside-month': isOutsideMonth ? '' : undefined,\n                    'data-outside-visible-months': isOutsideVisibleMonths ? '' : undefined,\n                    'data-focused': isFocusedDate ? '' : undefined,\n                    tabindex: isFocusedDate ? 0 : isOutsideMonth || isDisabled ? undefined : -1,\n                };\n            };\n        },\n        action: (node) => {\n            const getElArgs = () => {\n                const value = node.getAttribute('data-value');\n                const label = node.getAttribute('data-label');\n                const disabled = node.hasAttribute('data-disabled');\n                return {\n                    value,\n                    label: label ?? node.textContent ?? null,\n                    disabled: disabled ? true : false,\n                };\n            };\n            const unsub = executeCallbacks(addMeltEventListener(node, 'click', () => {\n                const args = getElArgs();\n                if (args.disabled)\n                    return;\n                if (!args.value)\n                    return;\n                handleCellClick(parseStringToDateValue(args.value, placeholder.get()));\n            }));\n            return {\n                destroy: unsub,\n            };\n        },\n    });\n    /**\n     * Synchronize the locale used within the formatter to ensure\n     * dynamic updates are reflected in the calendar.\n     */\n    effect([locale], ([$locale]) => {\n        if (formatter.getLocale() === $locale)\n            return;\n        formatter.setLocale($locale);\n    });\n    /**\n     * Updates the displayed months based on changes in the placeholder value,\n     * which determines the months to show in the calendar.\n     */\n    effect([placeholder], ([$placeholder]) => {\n        if (!isBrowser || !$placeholder)\n            return;\n        const $visibleMonths = visibleMonths.get();\n        /**\n         * If the placeholder's month is already in the visible months,\n         * we don't need to do anything.\n         */\n        if ($visibleMonths.some((month) => isSameMonth(month, $placeholder))) {\n            return;\n        }\n        const $weekStartsOn = weekStartsOn.get();\n        const $locale = locale.get();\n        const $fixedWeeks = fixedWeeks.get();\n        const $numberOfMonths = numberOfMonths.get();\n        const defaultMonthProps = {\n            weekStartsOn: $weekStartsOn,\n            locale: $locale,\n            fixedWeeks: $fixedWeeks,\n            numberOfMonths: $numberOfMonths,\n        };\n        months.set(createMonths({\n            ...defaultMonthProps,\n            dateObj: $placeholder,\n        }));\n    });\n    /**\n     * Updates the displayed months based on changes in the the options values,\n     * which determines the months to show in the calendar.\n     */\n    effect([weekStartsOn, locale, fixedWeeks, numberOfMonths], ([$weekStartsOn, $locale, $fixedWeeks, $numberOfMonths]) => {\n        const $placeholder = placeholder.get();\n        if (!isBrowser || !$placeholder)\n            return;\n        const defaultMonthProps = {\n            weekStartsOn: $weekStartsOn,\n            locale: $locale,\n            fixedWeeks: $fixedWeeks,\n            numberOfMonths: $numberOfMonths,\n        };\n        months.set(createMonths({\n            ...defaultMonthProps,\n            dateObj: $placeholder,\n        }));\n    });\n    /**\n     * Update the accessible heading's text content when the\n     * `fullCalendarLabel` store changes.\n     */\n    effect([fullCalendarLabel], ([$fullCalendarLabel]) => {\n        if (!isBrowser)\n            return;\n        const node = document.getElementById(ids.accessibleHeading.get());\n        if (!isHTMLElement(node))\n            return;\n        node.textContent = $fullCalendarLabel;\n    });\n    /**\n     * Synchronizing the placeholder value with the current value.\n     */\n    effect([value], ([$value]) => {\n        if (Array.isArray($value) && $value.length) {\n            const lastValue = $value[$value.length - 1];\n            if (lastValue && placeholder.get() !== lastValue) {\n                placeholder.set(lastValue);\n            }\n        }\n        else if (!Array.isArray($value) && $value && placeholder.get() !== $value) {\n            placeholder.set($value);\n        }\n    });\n    /**\n     * This derived store holds an array of localized day names for the current\n     * locale and calendar view. It dynamically syncs with the 'weekStartsOn' option,\n     * updating its content when the option changes. Using this store to render the\n     * calendar's days of the week is strongly recommended, as it guarantees that\n     * the days are correctly formatted for the current locale and calendar view.\n     *\n     * @example\n     * ```svelte\n     * <table use:melt={$grid} class=\"w-full\">\n     * \t<thead aria-hidden=\"true\">\n     * \t\t<tr>\n     * \t\t\t{#each $weekdays as day}\n     * \t\t\t\t<th class=\"text-sm font-semibold text-magnum-800\">\n     * \t\t\t\t\t<div class=\"flex h-6 w-6 items-center justify-center p-4\">\n     * \t\t\t\t\t\t{day}\n     * \t\t\t\t\t</div>\n     * \t\t\t\t</th>\n     * \t\t\t{/each}\n     * \t\t</tr>\n     * \t</thead>\n     * \t<!-- ... -->\n     * </table>\n     * ```\n     *\n     * If you prefer to format/render the days of the week yourself,\n     * you can do so by accessing the first week of the first month,\n     * and mapping over the dates to get/format each day of the week.\n     *\n     * @example\n     * ```svelte\n     * {#each $months as month}\n     * \t<table use:melt={$grid} class=\"w-full\">\n     * \t\t<thead aria-hidden=\"true\">\n     * \t\t\t<tr>\n     * \t\t\t\t{#each month.weeks[0] as dayOfWeek}\n     * \t\t\t\t\t<th class=\"text-sm font-semibold text-magnum-800\">\n     * \t\t\t\t\t\t<div class=\"flex h-6 w-6 items-center justify-center p-4\">\n     * \t\t\t\t\t\t\t{new Intl.DateTimeFormat('en', { weekday: 'long' }).format\n     * \t\t\t\t\t\t\t(dayOfWeek)}\n     * \t\t\t\t\t\t</div>\n     * \t\t\t\t\t</th>\n     * \t\t\t\t{/each}\n     * \t\t\t</tr>\n     * \t\t</thead>\n     * \t\t<!-- ... -->\n     * \t</table>\n     * {/each}\n     * ```\n     *\n     */\n    const weekdays = derived([months, weekdayFormat, locale], ([$months, $weekdayFormat, _]) => {\n        if (!$months.length)\n            return [];\n        return $months[0].weeks[0].map((date) => {\n            return formatter.dayOfWeek(toDate(date), $weekdayFormat);\n        });\n    });\n    /**\n     * Creates an accessible heading for the calendar, ensuring that\n     * when it is focused by a screen reader, the displayed date range\n     * is announced. This approach maintains accessibility for screen\n     * readers while keeping the heading hidden from the visual design\n     * of the calendar.\n     */\n    function createAccessibleHeading(node, label) {\n        if (!isBrowser)\n            return;\n        const div = document.createElement('div');\n        div.style.cssText = styleToString({\n            border: '0px',\n            clip: 'rect(0px, 0px, 0px, 0px)',\n            'clip-path': 'inset(50%)',\n            height: '1px',\n            margin: '-1px',\n            overflow: 'hidden',\n            padding: '0px',\n            position: 'absolute',\n            'white-space': 'nowrap',\n            width: '1px',\n        });\n        const h2 = document.createElement('div');\n        h2.textContent = label;\n        h2.id = ids.accessibleHeading.get();\n        h2.role = 'heading';\n        h2.ariaLevel = '2';\n        node.insertBefore(div, node.firstChild);\n        div.appendChild(h2);\n    }\n    /**\n     * Navigate to the next page of the calendar.\n     *\n     * @remarks\n     * If using paged navigation, this will move the calendar forward\n     * by the number of months specified in the `numberOfMonths` prop.\n     * If not using paged navigation, this will move the calendar forward\n     * by one month.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextPage } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={nextPage} aria-label=\"Next page\"></button>\n     * ```\n     */\n    function nextPage() {\n        const $months = months.get();\n        const $numberOfMonths = numberOfMonths.get();\n        if (pagedNavigation.get()) {\n            const firstMonth = $months[0].value;\n            placeholder.set(firstMonth.add({ months: $numberOfMonths }));\n        }\n        else {\n            const firstMonth = $months[0].value;\n            const newMonths = createMonths({\n                dateObj: firstMonth.add({ months: 1 }),\n                weekStartsOn: weekStartsOn.get(),\n                locale: locale.get(),\n                fixedWeeks: fixedWeeks.get(),\n                numberOfMonths: $numberOfMonths,\n            });\n            months.set(newMonths);\n            placeholder.set(newMonths[0].value.set({ day: 1 }));\n        }\n    }\n    /**\n     * Navigate to the previous page of the calendar.\n     *\n     * @remarks\n     * A helper function to navigate to the previous page of the calendar.\n     * If using paged navigation, this will move the calendar backwards\n     * by the number of months specified in the `numberOfMonths` prop.\n     * If not using paged navigation, this will move the calendar backwards\n     * by one month.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { prevPage } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevPage} aria-label=\"Previous page\"></button>\n     * ```\n     */\n    function prevPage() {\n        const $months = months.get();\n        const $numberOfMonths = numberOfMonths.get();\n        if (pagedNavigation.get()) {\n            const firstMonth = $months[0].value;\n            placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));\n        }\n        else {\n            const firstMonth = $months[0].value;\n            const newMonths = createMonths({\n                dateObj: firstMonth.subtract({ months: 1 }),\n                weekStartsOn: weekStartsOn.get(),\n                locale: locale.get(),\n                fixedWeeks: fixedWeeks.get(),\n                numberOfMonths: $numberOfMonths,\n            });\n            months.set(newMonths);\n            placeholder.set(newMonths[0].value.set({ day: 1 }));\n        }\n    }\n    /**\n     * Navigate to the next year in the calendar.\n     *\n     * @remarks\n     * A helper function to navigate to the next year in the calendar,\n     * which is useful if you want to extend the calendar to have buttons\n     * to navigate to the next/prev year.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextYear, prevYear } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevYear} aria-label=\"Previous year\"></button>\n     * <button on:click={nextYear} aria-label=\"Next year\"></button>\n     *\n     * ```\n     */\n    function nextYear() {\n        placeholder.add({ years: 1 });\n    }\n    /**\n     * A helper function to navigate to the previous year in the calendar,\n     * which is useful if you want to extend the calendar to have buttons\n     * to navigate to the next/prev year.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { nextYear, prevYear } } = createCalendar()\n     * </script>\n     *\n     * <button on:click={prevYear} aria-label=\"Previous year\"></button>\n     * <button on:click={nextYear} aria-label=\"Next year\"></button>\n     *\n     * ```\n     */\n    function prevYear() {\n        placeholder.subtract({ years: 1 });\n    }\n    const ARROW_KEYS = [kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.ARROW_LEFT, kbd.ARROW_RIGHT];\n    /**\n     * Set the year of the calendar to the specified year.\n     *\n     * @remarks\n     * This is useful if you want to extend the calendar to have\n     * alternative ways to change the year, such as a select input.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { setYear } } = createCalendar()\n     *\n     * \tlet selectValue = 2023;\n     * \t$: setYear(selectValue);\n     * </script>\n     *\n     * <select bind:value={selectValue} aria-label='Select a year'>\n     * \t<option value={2023}>2023</option>\n     * \t<option value={2024}>2024</option>\n     * \t<option value={2025}>2025</option>\n     * \t<!-- ... -->\n     * </select>\n     * ```\n     */\n    function setYear(year) {\n        placeholder.setDate({ year: year });\n    }\n    /**\n     * Set the month of the calendar to the specified month.\n     *\n     * @remarks\n     * This is useful if you want to extend the calendar to have\n     * alternative ways to change the month, such as a select input.\n     *\n     * @example\n     * ```svelte\n     * <script>\n     * \timport { createCalendar } from '@melt-ui/svelte';\n     * \tconst { { ... }, helpers: { setMonth } } = createCalendar()\n     *\n     * \tlet selectValue = 1;\n     * \t$: setMonth(selectValue);\n     * </script>\n     *\n     * <select bind:value={selectValue} aria-label='Select a month'>\n     * \t<option value={1}>January</option>\n     * \t<option value={2}>February</option>\n     * \t<option value={3}>March</option>\n     * \t<!-- ... -->\n     * </select>\n     * ```\n     */\n    function setMonth(month) {\n        placeholder.setDate({ month: month });\n    }\n    function handleCellClick(date) {\n        const $readonly = readonly.get();\n        if ($readonly)\n            return;\n        const $isDateDisabled = isDateDisabled.get();\n        const $isUnavailable = options.isDateUnavailable.get();\n        if ($isDateDisabled?.(date) || $isUnavailable?.(date))\n            return;\n        value.update((prev) => {\n            const $multiple = multiple.get();\n            if ($multiple) {\n                return handleMultipleUpdate(prev, date);\n            }\n            else {\n                const next = handleSingleUpdate(prev, date);\n                if (!next) {\n                    announcer.announce('Selected date is now empty.', 'polite', 5000);\n                }\n                else {\n                    announcer.announce(`Selected Date: ${formatter.selectedDate(next, false)}`, 'polite');\n                }\n                return next;\n            }\n        });\n    }\n    function handleSingleUpdate(prev, date) {\n        if (Array.isArray(prev))\n            throw new Error('Invalid value for multiple prop.');\n        if (!prev)\n            return date;\n        const $preventDeselect = preventDeselect.get();\n        if (!$preventDeselect && isSameDay(prev, date)) {\n            placeholder.set(date);\n            return undefined;\n        }\n        return date;\n    }\n    function handleMultipleUpdate(prev, date) {\n        if (!prev)\n            return [date];\n        if (!Array.isArray(prev))\n            throw new Error('Invalid value for multiple prop.');\n        const index = prev.findIndex((d) => isSameDay(d, date));\n        const $preventDeselect = preventDeselect.get();\n        if (index === -1) {\n            return [...prev, date];\n        }\n        else if ($preventDeselect) {\n            return prev;\n        }\n        else {\n            const next = prev.filter((d) => !isSameDay(d, date));\n            if (!next.length) {\n                placeholder.set(date);\n                return undefined;\n            }\n            return next;\n        }\n    }\n    const SELECT_KEYS = [kbd.ENTER, kbd.SPACE];\n    function handleCalendarKeydown(e) {\n        const currentCell = e.target;\n        if (!isCalendarCell(currentCell))\n            return;\n        if (!ARROW_KEYS.includes(e.key) && !SELECT_KEYS.includes(e.key))\n            return;\n        e.preventDefault();\n        // the cell that is currently focused\n        if (e.key === kbd.ARROW_DOWN) {\n            shiftFocus(currentCell, 7);\n        }\n        if (e.key === kbd.ARROW_UP) {\n            shiftFocus(currentCell, -7);\n        }\n        if (e.key === kbd.ARROW_LEFT) {\n            shiftFocus(currentCell, -1);\n        }\n        if (e.key === kbd.ARROW_RIGHT) {\n            shiftFocus(currentCell, 1);\n        }\n        if (e.key === kbd.SPACE || e.key === kbd.ENTER) {\n            const cellValue = currentCell.getAttribute('data-value');\n            if (!cellValue)\n                return;\n            handleCellClick(parseStringToDateValue(cellValue, placeholder.get()));\n        }\n    }\n    function shiftFocus(node, add) {\n        const candidateCells = getSelectableCells(ids.calendar.get());\n        if (!candidateCells.length)\n            return;\n        const index = candidateCells.indexOf(node);\n        const nextIndex = index + add;\n        /**\n         * If the next cell is within the bounds of the\n         * displayed/rendered cells, easy day, just focus it.\n         */\n        if (isValidIndex(nextIndex, candidateCells)) {\n            const nextCell = candidateCells[nextIndex];\n            setPlaceholderToNodeValue(nextCell, placeholder);\n            return nextCell.focus();\n        }\n        /**\n         * When the next cell falls outside the displayed/rendered cells range,\n         * we update the focus to the previous or next month based on the direction,\n         * and then focus on the relevant cell.\n         */\n        if (nextIndex < 0) {\n            /**\n             * To handle negative index values, we rewind by one month,\n             * retrieve candidate cells for that month, and shift the focus\n             * by the difference between the nextIndex starting from the end\n             * of the array.\n             */\n            // shift the calendar back a month unless previous month is disabled\n            if (isPrevButtonDisabled.get())\n                return;\n            const $months = months.get();\n            const firstMonth = $months[0].value;\n            const $numberOfMonths = numberOfMonths.get();\n            placeholder.set(firstMonth.subtract({ months: $numberOfMonths }));\n            // Without a tick here, it seems to be too fast for\n            // the DOM to update, with the tick it works great\n            tick().then(() => {\n                const newCandidateCells = getSelectableCells(ids.calendar.get());\n                if (!newCandidateCells.length) {\n                    return;\n                }\n                /**\n                 * Starting at the end of the array, shift focus by the\n                 * difference between the nextIndex and the length of the\n                 * array, since the nextIndex is negative.\n                 */\n                const newIndex = newCandidateCells.length - Math.abs(nextIndex);\n                if (isValidIndex(newIndex, newCandidateCells)) {\n                    const newCell = newCandidateCells[newIndex];\n                    setPlaceholderToNodeValue(newCell, placeholder);\n                    return newCell.focus();\n                }\n            });\n        }\n        if (nextIndex >= candidateCells.length) {\n            /**\n             * Since we're in the positive index range, we need to\n             * go forward a month, refetch the candidate cells within that\n             * month, and then starting at the beginning of that array,\n             * shift focus by the nextIndex amount.\n             */\n            // shift the calendar forward a month unless next month is disabled\n            if (isNextButtonDisabled.get())\n                return;\n            const $months = months.get();\n            const firstMonth = $months[0].value;\n            const $numberOfMonths = numberOfMonths.get();\n            placeholder.set(firstMonth.add({ months: $numberOfMonths }));\n            tick().then(() => {\n                const newCandidateCells = getSelectableCells(ids.calendar.get());\n                if (!newCandidateCells.length) {\n                    return;\n                }\n                /**\n                 * We need to determine how far into the next month we need to go\n                 * to get the next index. So if we only went over the previous\n                 * month by 1, we need to go into the next month by 1 to get the\n                 * right index.\n                 */\n                const newIndex = nextIndex - candidateCells.length;\n                if (isValidIndex(newIndex, newCandidateCells)) {\n                    const nextCell = newCandidateCells[newIndex];\n                    return nextCell.focus();\n                }\n            });\n        }\n    }\n    /**\n     * A helper function to determine if a date cell is disabled,\n     * which uses the `Matcher`(s) provided via the `isDisabled`\n     * prop, as well as other internal logic, such as if it's\n     * outside of the month, or if it's before/after the min/max\n     * values.\n     *\n     * Although we set attributes on the cells themselves, for\n     * easy styling this function is useful when you want to\n     * conditionally handle something outside of the cell,\n     * such as its wrapping element.\n     *\n     * @example\n     * ```svelte\n     * {#each dates as date}\n     * \t<td role=\"gridcell\" aria-disabled={$isDisabled(date)}>\n     * \t\t<!-- ... -->\n     * \t</td>\n     * {/each}\n     * ```\n     *\n     * @param date - The `DateValue` to check\n     * @returns `true` if the date is disabled, `false` otherwise\n     */\n    const _isDateDisabled = derived([isDateDisabled, placeholder, minValue, maxValue, disabled], ([$isDateDisabled, $placeholder, $minValue, $maxValue, $disabled]) => {\n        return (date) => {\n            if ($isDateDisabled?.(date) || $disabled)\n                return true;\n            if ($minValue && isBefore(date, $minValue))\n                return true;\n            if ($maxValue && isAfter(date, $maxValue))\n                return true;\n            if (!isSameMonth(date, $placeholder))\n                return true;\n            return false;\n        };\n    });\n    /**\n     * A helper function to determine if a date is unavailable,\n     * which uses the `Matcher`(s) provided via the `unavailable`\n     * prop.\n     *\n     * Although we set attributes on the cells themselves, this\n     * function is useful when you want to conditionally handle\n     * something outside of the cell, such as its wrapping element.\n     *\n     * @example\n     * ```svelte\n     * {#each dates as date}\n     * \t<td role=\"gridcell\">\n     * \t\t{#if $isUnavailable(date)}\n     * \t\t\t<span>X</span>\n     * \t\t{/if}\n     * \t\t<!-- ... -->\n     * \t</td>\n     * {/each}\n     * ```\n     *\n     * @param date - The `DateValue` to check\n     * @returns `true` if the date is disabled, `false` otherwise\n     */\n    const _isDateUnavailable = derived(isDateUnavailable, ($isDateUnavailable) => {\n        return (date) => $isDateUnavailable?.(date);\n    });\n    return {\n        elements: {\n            calendar,\n            heading,\n            grid,\n            cell,\n            nextButton,\n            prevButton,\n        },\n        states: {\n            placeholder: placeholder.toWritable(),\n            months,\n            value,\n            weekdays,\n            headingValue,\n        },\n        helpers: {\n            nextPage,\n            prevPage,\n            nextYear,\n            prevYear,\n            setYear,\n            setMonth,\n            isDateDisabled: _isDateDisabled,\n            isDateSelected,\n            isDateUnavailable: _isDateUnavailable,\n        },\n        options,\n        ids,\n    };\n}\n","import { createCalendar, createDateField, createPopover } from '../index.js';\nimport { handleSegmentNavigation, isSegmentNavigationKey, } from '../../internal/helpers/date/index.js';\nimport { addMeltEventListener, makeElement, effect, omit, toWritableStores, } from '../../internal/helpers/index.js';\nimport { pickerOpenFocus } from '../../internal/helpers/date/focus.js';\nimport { createFormatter, dateStore, getDefaultDate } from '../../internal/helpers/date/index.js';\nimport { defaults as calendarDefaults } from '../calendar/create.js';\nconst defaults = {\n    isDateDisabled: undefined,\n    isDateUnavailable: undefined,\n    value: undefined,\n    positioning: {\n        placement: 'bottom',\n    },\n    closeOnEscape: true,\n    closeOnOutsideClick: true,\n    onOutsideClick: undefined,\n    preventScroll: false,\n    forceVisible: false,\n    locale: 'en',\n    granularity: undefined,\n    disabled: false,\n    readonly: false,\n    minValue: undefined,\n    maxValue: undefined,\n    weekdayFormat: 'narrow',\n    ...omit(calendarDefaults, 'isDateDisabled', 'isDateUnavailable', 'value', 'locale', 'disabled', 'readonly', 'minValue', 'maxValue', 'weekdayFormat'),\n};\nexport function createDatePicker(props) {\n    const withDefaults = { ...defaults, ...props };\n    const options = toWritableStores(omit(withDefaults, 'value', 'placeholder'));\n    const dateField = createDateField({\n        ...withDefaults,\n        ids: withDefaults.dateFieldIds,\n    });\n    const { states: { value, placeholder: dfPlaceholder }, } = dateField;\n    const calendar = createCalendar({\n        ...omit(withDefaults, 'onValueChange'),\n        placeholder: dfPlaceholder,\n        value: value,\n        ids: withDefaults.calendarIds,\n    });\n    const popover = createPopover({\n        positioning: withDefaults.positioning,\n        arrowSize: withDefaults.arrowSize,\n        defaultOpen: withDefaults.defaultOpen,\n        open: withDefaults.open,\n        disableFocusTrap: withDefaults.disableFocusTrap,\n        closeOnEscape: withDefaults.closeOnEscape,\n        preventScroll: withDefaults.preventScroll,\n        onOpenChange: withDefaults.onOpenChange,\n        closeOnOutsideClick: withDefaults.closeOnOutsideClick,\n        portal: withDefaults.portal,\n        forceVisible: withDefaults.forceVisible,\n        openFocus: pickerOpenFocus,\n        ids: withDefaults.popoverIds,\n        onOutsideClick: withDefaults.onOutsideClick,\n    });\n    const trigger = makeElement('popover-trigger', {\n        stores: [popover.elements.trigger, options.disabled],\n        returned: ([$trigger, $disabled]) => {\n            return {\n                ...omit($trigger, 'action'),\n                'aria-label': 'Open date picker',\n                'data-segment': 'trigger',\n                disabled: $disabled ? true : undefined,\n            };\n        },\n        action: (node) => {\n            const unsubKeydown = addMeltEventListener(node, 'keydown', handleTriggerKeydown);\n            const { destroy } = popover.elements.trigger(node);\n            return {\n                destroy() {\n                    destroy?.();\n                    unsubKeydown();\n                },\n            };\n        },\n    });\n    const formatter = createFormatter(options.locale.get());\n    effect([options.locale], ([$locale]) => {\n        dateField.options.locale.set($locale);\n        calendar.options.locale.set($locale);\n        if (formatter.getLocale() === $locale)\n            return;\n        formatter.setLocale($locale);\n    });\n    effect([options.weekdayFormat], ([$weekdayFormat]) => {\n        calendar.options.weekdayFormat.set($weekdayFormat);\n    });\n    effect([options.disabled], ([$disabled]) => {\n        dateField.options.disabled.set($disabled);\n        calendar.options.disabled.set($disabled);\n    });\n    effect([options.readonly], ([$readonly]) => {\n        dateField.options.readonly.set($readonly);\n        calendar.options.readonly.set($readonly);\n    });\n    effect([options.minValue], ([$minValue]) => {\n        dateField.options.minValue.set($minValue);\n        calendar.options.minValue.set($minValue);\n    });\n    effect([options.maxValue], ([$maxValue]) => {\n        dateField.options.maxValue.set($maxValue);\n        calendar.options.maxValue.set($maxValue);\n    });\n    effect([options.numberOfMonths], ([$numberOfMonths]) => {\n        calendar.options.numberOfMonths.set($numberOfMonths);\n    });\n    effect([options.fixedWeeks], ([$fixedWeeks]) => {\n        calendar.options.fixedWeeks.set($fixedWeeks);\n    });\n    effect([options.weekStartsOn], ([$weekStartsOn]) => {\n        calendar.options.weekStartsOn.set($weekStartsOn);\n    });\n    const dateFieldOptions = omit(dateField.options, 'locale', 'disabled', 'readonly', 'minValue', 'maxValue');\n    const calendarOptions = omit(calendar.options, 'locale', 'disabled', 'readonly', 'minValue', 'maxValue');\n    const { states: { open }, } = popover;\n    const defaultDate = getDefaultDate({\n        defaultPlaceholder: withDefaults.defaultPlaceholder,\n        defaultValue: withDefaults.defaultValue,\n        granularity: withDefaults.granularity,\n    });\n    const placeholder = dateStore(dfPlaceholder, withDefaults.defaultPlaceholder ?? defaultDate);\n    effect([open], ([$open]) => {\n        if (!$open) {\n            const $value = value.get();\n            if ($value) {\n                placeholder.set($value);\n            }\n            else {\n                placeholder.reset();\n            }\n        }\n    });\n    function handleTriggerKeydown(e) {\n        if (isSegmentNavigationKey(e.key)) {\n            e.preventDefault();\n            handleSegmentNavigation(e, dateField.ids.field.get());\n        }\n    }\n    return {\n        elements: {\n            ...calendar.elements,\n            ...dateField.elements,\n            ...popover.elements,\n            trigger,\n        },\n        states: {\n            ...dateField.states,\n            ...calendar.states,\n            placeholder: placeholder.toWritable(),\n            value,\n            ...popover.states,\n        },\n        helpers: {\n            ...calendar.helpers,\n        },\n        options: {\n            ...dateFieldOptions,\n            ...calendarOptions,\n            ...options,\n            ...popover.options,\n        },\n        ids: {\n            dateField: dateField.ids,\n            calendar: calendar.ids,\n            popover: popover.ids,\n        },\n    };\n}\n","export const bits = [\n    \"accordion\",\n    \"alert-dialog\",\n    \"aspect-ratio\",\n    \"avatar\",\n    \"button\",\n    \"calendar\",\n    \"checkbox\",\n    \"collapsible\",\n    \"combobox\",\n    \"context-menu\",\n    \"date-field\",\n    \"date-picker\",\n    \"date-range-field\",\n    \"date-range-picker\",\n    \"dialog\",\n    \"dropdown-menu\",\n    \"label\",\n    \"link-preview\",\n    \"menubar\",\n    \"pagination\",\n    \"pin-input\",\n    \"popover\",\n    \"progress\",\n    \"radio-group\",\n    \"range-calendar\",\n    \"scroll-area\",\n    \"select\",\n    \"separator\",\n    \"slider\",\n    \"switch\",\n    \"tabs\",\n    \"toggle\",\n    \"toggle-group\",\n    \"toolbar\",\n    \"tooltip\",\n];\nexport function createBitAttrs(bit, parts) {\n    const attrs = {};\n    parts.forEach((part) => {\n        attrs[part] = {\n            [`data-${bit}-${part}`]: \"\",\n        };\n    });\n    return (part) => attrs[part];\n}\nexport function disabledAttrs(disabled) {\n    return disabled\n        ? { \"aria-disabled\": \"true\", \"data-disabled\": \"\" }\n        : { \"aria-disabled\": undefined, \"data-disabled\": undefined };\n}\n","import { createEventDispatcher } from \"svelte\";\nexport function createDispatcher() {\n    const dispatch = createEventDispatcher();\n    return (e) => {\n        const { originalEvent } = e.detail;\n        const { cancelable } = e;\n        const type = originalEvent.type;\n        const shouldContinue = dispatch(type, { originalEvent, currentTarget: originalEvent.currentTarget }, { cancelable });\n        if (!shouldContinue) {\n            e.preventDefault();\n        }\n    };\n}\n","export function removeUndefined(obj) {\n    const result = {};\n    for (const key in obj) {\n        const value = obj[key];\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n","export function getOptionUpdater(options) {\n    return function (key, value) {\n        if (value === undefined)\n            return;\n        const store = options[key];\n        if (store) {\n            store.set(value);\n        }\n    };\n}\n","export function getPositioningUpdater(store) {\n    return (props = {}) => {\n        return updatePositioning(store, props);\n    };\n}\nexport function updatePositioning(store, props) {\n    const defaultPositioningProps = {\n        side: \"bottom\",\n        align: \"center\",\n        sideOffset: 0,\n        alignOffset: 0,\n        sameWidth: false,\n        avoidCollisions: true,\n        collisionPadding: 8,\n        fitViewport: false,\n        strategy: \"absolute\",\n        overlap: false,\n    };\n    const withDefaults = { ...defaultPositioningProps, ...props };\n    store.update((prev) => {\n        return {\n            ...prev,\n            placement: joinPlacement(withDefaults.side, withDefaults.align),\n            offset: {\n                ...prev.offset,\n                mainAxis: withDefaults.sideOffset,\n                crossAxis: withDefaults.alignOffset,\n            },\n            gutter: 0,\n            sameWidth: withDefaults.sameWidth,\n            flip: withDefaults.avoidCollisions,\n            overflowPadding: withDefaults.collisionPadding,\n            boundary: withDefaults.collisionBoundary,\n            fitViewport: withDefaults.fitViewport,\n            strategy: withDefaults.strategy,\n            overlap: withDefaults.overlap,\n        };\n    });\n}\nfunction joinPlacement(side, align) {\n    if (align === \"center\")\n        return side;\n    return `${side}-${align}`;\n}\n"],"names":["has","find","iter","tar","key","dequal","foo","bar","ctor","len","tmp","back","array","index","increment","loop","previousIndex","forward","nextIndex","next","prev","currentIndex","last","wrapArray","startIndex","_","toggle","item","compare","deepEqual","itemIdx","innerItem","styleToString","style","str","disabledAttr","disabled","portalAttr","portal","lightable","value","subscribe","run","getElementByMeltId","id","isBrowser","el","isHTMLElement","hiddenAction","obj","target","prop","receiver","isFunctionWithParams","fn","makeElement","name","args","stores","action","returned","derivedStore","derived","values","result","noop","returnedFn","resultFn","actionFn","createElHelpers","prefix","part","attribute","selector","isFunction","v","isElement","element","isHTMLInputElement","isHTMLLabelElement","isHTMLButtonElement","isElementDisabled","ariaDisabled","dataDisabled","isTouch","event","isFocusVisible","isObject","isReadable","executeCallbacks","callbacks","callback","addEventListener","handler","options","events","_event","addMeltEventListener","handlerWithMelt","withMelt","dispatchMeltEvent","originalEvent","node","customMeltEvent","customEvent","safeOnMount","onMount","safeOnDestroy","onDestroy","omit","keys","stripValues","inputObject","toStrip","recursive","removeUndefined","withGet","store","get","initial","internal","writable","newValue","updater","subscribers","subscriber","unsubscribers","unsubscribe","overridable","_store","onChange","update","sideEffect","curr","res","sleep","ms","resolve","urlAlphabet","nanoid","size","i","generateId","generateIds","acc","kbd","FIRST_KEYS","LAST_KEYS","FIRST_LAST_KEYS","SELECTION_KEYS","derivedVisible","open","forceVisible","activeTrigger","$open","$forceVisible","$activeTrigger","effect","cb","destroy","unsub","toWritableStores","properties","propertyKey","getPortalParent","parent","getPortalDestination","portalProp","readable","set","clicked","documentEscapeKeyStore","keydown","useEscapeKeydown","config","enabled","e","ignoreEl","_a","$enabled","min","max","round","floor","createCoords","oppositeSideMap","oppositeAlignmentMap","clamp","start","end","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","yAxisSides","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","lrPlacement","rlPlacement","tbPlacement","btPlacement","getSideList","side","isStart","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","x","y","width","height","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","strategy","middleware","platform","validMiddleware","statefulPlacement","middlewareData","resetCount","nextX","nextY","data","reset","detectOverflow","state","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","placements","overflow","overflows","overflowsData","sides","_middlewareData$flip2","_overflowsData$filter","nextPlacement","d","resetPlacement","a","b","_overflowsData$filter2","currentSideAxis","originSides","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","_state$middlewareData","_state$middlewareData2","apply","heightSide","widthSide","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","hasWindow","getNodeName","isNode","getWindow","_node$ownerDocument","getDocumentElement","isShadowRoot","invalidOverflowDisplayValues","isOverflowElement","overflowX","overflowY","display","getComputedStyle","tableElements","isTableElement","topLayerSelectors","isTopLayer","transformProperties","willChangeValues","containValues","isContainingBlock","elementOrCss","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","lastTraversableNodeNames","getNodeScroll","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","getWindowScrollBarX","leftScroll","getHTMLOffset","documentElement","scroll","ignoreScrollbarX","htmlRect","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","offsets","isOffsetParentAnElement","offsetRect","htmlOffset","getClientRects","getDocumentRect","html","body","getViewportRect","visualViewport","visualViewportBased","absoluteOrFixed","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","setLeftRTLScrollbarOffset","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","getOffsetParent","svgOffsetParent","getElementRects","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","rectsAreEqual","observeMove","onMove","io","timeoutId","root","cleanup","_io","refresh","skip","threshold","elementRectForRootMargin","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","offset$1","shift$1","flip$1","size$1","arrow$1","mergedOptions","platformWithCache","computePosition$1","defaultConfig","ARROW_TRANSFORM","useFloating","opts","arrowEl","arrowOffset","compute","align","getSideAndAlignFromPlacement","dir","createFocusTrap","trap","immediate","focusTrapOptions","hasFocus","isPaused","activate","deactivate","pause","unpause","_createFocusTrap","readonly","visibleModals","useModal","unsubInteractOutside","removeNodeFromVisibleModals","onClose","shouldCloseOnInteractOutside","closeOnInteractOutside","isLastModal","closeModal","onInteractOutsideStart","onInteractOutside","useInteractOutside","usePopper","popperElement","anchorElement","usePortal","useFocusTrap","targetEl","newTarget","tick","unsubClick","isPointerDown","isPointerDownInside","ignoreEmulatedMouseEvents","onPointerDown","isValidEvent","isOrContainsTarget","triggerInteractOutside","documentObj","getOwnerDocument","onPointerUp","shouldTriggerInteractOutside","resetPointerState","onMouseUp","onTouchEnd","ownerDocument","toReadableStores","defaults","createHiddenInput","props","withDefaults","elName","required","nameStore","$value","$name","$disabled","$required","calendarDefaults","createBitAttrs","bit","parts","attrs","disabledAttrs","createDispatcher","dispatch","createEventDispatcher","cancelable","type","getOptionUpdater","getPositioningUpdater","updatePositioning","joinPlacement"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]}